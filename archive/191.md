# 位 1 的个数

难度： 简单

关键词： 位运算

## 题目描述

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

示例 1：

>**输入**： `00000000000000000000000000001011` <br>
**输出**： `3` <br>
**解释**： 输入的二进制串 `00000000000000000000000000001011` 中，共有三位为 '1'。

示例 2：

>**输入**： `00000000000000000000000010000000` <br>
**输出**： `1` <br>
**解释**： 输入的二进制串 `00000000000000000000000010000000` 中，共有一位为 '1'。

示例 3：

>**输入**： `11111111111111111111111111111101` <br>
**输出**： `31` <br>
**解释**： 输入的二进制串 `11111111111111111111111111111101` 中，共有 31 位为 '1'。

提示：

* 输入必须是长度为 `32` 的 二进制串 。

进阶：

* 如果多次调用这个函数，你将如何优化你的算法？

## 题解

### 方法一：循环检查二进制位

#### 思路及算法

我们可以直接循环检查给定整数 $n$ 的二进制位的每一位是否为 $1$。

#### 代码

```cpp
class Solution {
 public:
  int hammingWeight(uint32_t n) {
    int res = 0;
    for (int i = 0; i < 32; ++i) {
      res += (n >> i) & 1;
    }
    return res;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(k)$，其中 $k$ 是 int 型的二进制位数， $k=32$。我们需要检查 $n$ 的二进制位的每一位，一共需要检查 $32$ 位。
* 空间复杂度： $O(1)$，我们只需要常数的空间保存若干变量。

### 方法二：位运算优化

#### 思路及算法

观察这个运算：$n~\&~(n - 1)$，其运算结果恰为把 $n$ 的二进制位中的最低位的 $1$ 变为 $0$ 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 $n$ 与 $n - 1$ 做与运算，直到 $n$ 变为 $0$ 即可。因为每次运算会使得 $n$ 的最低位的 $1$ 被翻转，因此运算次数就等于 $n$ 的二进制位中 $1$ 的个数。

#### 代码

```cpp
class Solution {
 public:
  int hammingWeight(uint32_t n) {
    int res = 0;
    while (n) {
      n &= n - 1;
      res++;
    }
    return res;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(\log n)$。循环次数等于 $n$ 的二进制位中 $1$ 的个数，最坏情况下 $n$ 的二进制位全部为 $1$。我们需要循环 $\log n$ 次。
* 空间复杂度： $O(1)$，我们只需要常数的空间保存若干变量。