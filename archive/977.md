# 有序数组的平方

难度： 简单

关键词： 双指针

## 题目描述

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

示例 1：

>**输入**： `nums = [-4,-1,0,3,10]` <br>
**输出**： `[0,1,9,16,100]` <br>
**解释**： 平方后，数组变为 `[16,1,0,9,100]`；排序后，数组变为 `[0,1,9,16,100]`

示例 2：

>**输入**： `nums = [-7,-3,2,3,11]` <br>
**输出**： `[4,9,9,49,121]`

提示：

* `1 <= nums.length <= 10^4`
* `-10^4 <= nums[i] <= 10^4`
* `nums` 已按 **非递减顺序** 排序

进阶：

* 请你设计时间复杂度为 $O(n)$ 的算法解决本问题

## 题解

### 双指针

#### 思路及算法

我们可以使用两个指针分别指向位置 $0$ 和 $n-1$，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况。

#### 代码

C++:
```cpp
class Solution {
 public:
  vector<int> sortedSquares(vector<int>& nums) {
    int len = nums.size();
    vector<int> res(len);
    for (int i = 0, j = len - 1, pos = len - 1; i <= j;) {
      if (abs(nums[i]) > abs(nums[j])) {
        res[pos] = nums[i] * nums[i];
        i++;
      } else {
        res[pos] = nums[j] * nums[j];
        j--;
      }
      pos--;
    }
    return res;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(n)$，其中 $n$ 是数组 $nums$ 的长度。
* 空间复杂度： $O(1)$。除了存储答案的数组以外，我们只需要维护常量空间。