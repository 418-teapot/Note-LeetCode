# 腐烂的橘子

难度： 中等

关键词： 矩阵、广度优先搜索

## 题目描述

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

* 值 `0` 代表空单元格；
* 值 `1` 代表新鲜橘子；
* 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围四个方向上相邻** 的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`。

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)

>**输入**： `grid = [[2,1,1],[1,1,0],[0,1,1]]` <br>
**输出**： `4`

示例 2：

>**输入**： `grid = [[2,1,1],[0,1,1],[1,0,1]]` <br>
**输出**： `-1` <br>
**解释**：左下角的橘子（第 2 行，第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。

示例 3：

>**输入**： `grid = [[0,2]]` <br>
**输出**： `0` <br>
**解释**：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。

提示：

* `m == grid.length`
* `n == grid[i].length`
* `1 <= m, n <= 10`
* `grid[i][j]` 仅为 `0`、`1` 或 `2`

## 题解

### 广度优先搜索

#### 思路及算法

观察到对于所有的腐烂橘子，其实它们在广度优先搜索上是等价于同一层的节点的。

假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(我们令其为超级源点)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 $-1$，那么按照广度优先搜索的算法，下一分钟也就是第 $0$ 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 $res$ 其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。

为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 $fresh$ 表示当前网格中的新鲜橘子数，广度优先搜索的时候如果有新鲜橘子被腐烂，则 $fresh-=1$，最后搜索结束时如果 $fresh$ 大于 $0$，说明有新鲜橘子没被腐烂，返回 $−1$，否则返回所有新鲜橘子被腐烂的时间的最大值即可，也可以在广度优先搜索的过程中把已腐烂的新鲜橘子的值由 $1$ 改为 $2$，最后看网格中是否有值为 $1$ 即新鲜的橘子即可。

#### 代码

C++:
```cpp
class Solution {
 public:
  const int dx[4] = {0, 0, -1, 1};
  const int dy[4] = {-1, 1, 0, 0};
  int orangesRotting(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    queue<pair<int, int>> q;
    int fresh = 0;
    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (grid[i][j] == 2) {
          q.emplace(i, j);
        } else if (grid[i][j] == 1) {
          fresh++;
        }
      }
    }

    int res = 0;
    while (fresh > 0 && !q.empty()) {
      int len = q.size();
      for (int k = 0; k < len; ++k) {
        auto [x, y] = q.front();
        q.pop();
        for (int d = 0; d < 4; ++d) {
          int nx = x + dx[d];
          int ny = y + dy[d];
          if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) {
            fresh--;
            grid[nx][ny] = 2;
            q.emplace(nx, ny);
          }
        }
      }
      res++;
    }

    return fresh > 0 ? -1 : res;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(mn)$，其中 $m$ 为矩阵行数， $n$ 为矩阵列数，即矩阵元素个数。广度优先搜索中每个位置最多只会被加入队列一次，因此只需要 $O(mn)$ 的时间复杂度。
* 空间复杂度： $O(mn)$。最坏情况下矩阵里所有元素都为 $0$，全部被加入队列中，此时需要 $O(mn)$ 的空间复杂度。