# 二进制间距

难度： 简单

关键词： 位运算、模拟

## 题目描述

给定一个正整数 `n`，找到并返回 `n` 的二进制表示中两个 **相邻** `1` 之间的 最长距离 。如果不存在两个相邻的 `1`，返回 `0`。

如果只有 `0` 将两个 `1` 分隔开（可能不存在 `0`），则认为这两个 `1` 彼此 **相邻**。两个 `1` 之间的距离是它们的二进制表示中位置的绝对差。例如， `"1001"` 中的两个 `1` 的距离为 `3`。

示例 1：

>**输入**： `n = 22` <br>
**输出**： `2` <br>
**解释**： 22 的二进制是 "10110" 。在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。第一对相邻的 1 中，两个 1 之间的距离为 2 。第二对相邻的 1 中，两个 1 之间的距离为 1 。答案取两个距离之中最大的，也就是 2 。

示例 2：

>**输入**： `n = 8` <br>
**输出**： `0` <br>
**解释**： 8 的二进制是 "1000" 。在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。

示例 3：

>**输入**： `n = 5` <br>
**输出**： `2` <br>
**解释**： 5 的二进制是 "101" 。

提示：

* `1 <= n <= 10^9`

## 题解

### 模拟

#### 思路及算法

根据题意进行模拟即可，遍历 $n$ 的二进制中的每一位 $i$，同时记录上一位 $1$ 的位置 $last$，即可得到所有相邻 $1$ 的间距，所有间距取 $max$ 即是答案。

#### 代码

C++:
```cpp
class Solution {
 public:
  int binaryGap(int n) {
    int res = 0;
    int last = -1;
    for (int i = 31; i >= 0; --i) {
      if (((n >> i) & 1) == 1) {
        if (last != -1) res = max(res, last - i);
        last = i;
      }
    }
    return res;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(\log n)$。循环中的每一步 $n$ 会减少一半，因此需要 $O(\log n)$ 次循环。
* 空间复杂度： $O(1)$。