# 全排列

难度： 中等

关键词： 回溯

## 题目描述

给定一个不含重复数字的数组 `nums`，返回其 **所有可能的全排列**。你可以 **按任意顺序** 返回答案。

示例 1：

>**输入**： `nums = [1,2,3]` <br>
**输出**： `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`

示例 2：

>**输入**： `nums = [0,1]` <br>
**输出**： `[[0,1],[1,0]]`

示例 3：

>**输入**： `nums = [1]` <br>
**输出**： `[[1]]`

提示：

* `1 <= nums.length <= 6`
* `-10 <= nums[i] <= 10`
* `nums` 中的所有整数 **互不相同**

## 题解

### 回溯

#### 思路及算法

这个问题可以看作有 $n$ 个排列成一行的空格，我们需要从左往右依此填入题目给定的 $n$ 个数，每个数只能使用一次。那么很直接的可以想到一种穷举的算法，即从左往右每一个位置都依此尝试填入一个数，看能不能填完这 $n$ 个空格，在程序中我们可以用「回溯法」来模拟这个过程。

我们定义递归函数 $backtrack(first,output)$ 表示从左往右填到第 $first$ 个位置，当前排列为 $output$。 那么整个递归函数分为两个情况：

* 如果 $first = n$，说明我们已经填完了 $n$ 个位置（注意下标从 $0$ 开始），找到了一个可行的解，我们将 $output$ 放入答案数组中，递归结束。
* 如果 $first < n$，我们要考虑这第 $first$ 个位置我们要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组 $vis$ 来标记已经填过的数，那么在填第 $first$ 个数的时候我们遍历题目给定的 $n$ 个数，如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数 $backtrack(first+1,output)$。回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他没被标记过的数。

使用标记数组来处理填过的数是一个很直观的思路，但是可不可以去掉这个标记数组呢？毕竟标记数组也增加了我们算法的空间复杂度。

答案是可以的，我们可以将题目给定的 $n$ 个数的数组 $nums$ 划分成左右两个部分，左边的表示已经填过的数，右边表示待填的数，我们在回溯的时候只要动态维护这个数组即可。

具体来说，假设我们已经填到第 $first$ 个位置，那么 $nums$ 数组中 $[0,first−1]$ 是已填过的数的集合， $[first,n−1]$ 是待填的数的集合。我们肯定是尝试用 $[first,n−1]$ 里的数去填第 $first$ 个数，假设待填的数的下标为 $i$，那么填完以后我们将第 $i$ 个数和第 $first$ 个数交换，即能使得在填第 $first+1$ 个数的时候 $nums$ 数组的 $[0,first]$ 部分为已填过的数，$[first+1,n−1]$ 为待填的数，回溯的时候交换回来即能完成撤销操作。

#### 代码

C++:
```cpp
class Solution {
 public:
  void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len) {
    if (first == len) {
      res.emplace_back(output);
      return;
    }
    for (int i = first; i < len; ++i) {
      swap(output[i], output[first]);
      backtrack(res, output, first+1, len);
      swap(output[i], output[first]);
    }
  }
  vector<vector<int>> permute(vector<int>& nums) {
    vector<vector<int>> res;
    vector<int> output(nums);
    backtrack(res, output, 0, nums.size());
    return res;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(n \times n!)$，其中 $n$ 为序列的长度。

    算法的复杂度首先受 $backtrack$ 的调用次数制约， $backtrack$ 的调用次数为 $\sum_{k = 1}^{n}{P(n, k)}$ 次，其中 $P(n, k) = \frac{n!}{(n - k)!} = n (n - 1) \ldots (n - k + 1)$，该式被称作 $n$ 的 $k -$ 排列，或者部分排列。

    而 $\sum_{k = 1}^{n}{P(n, k)} = n! + \frac{n!}{1!} + \frac{n!}{2!} + \frac{n!}{3!} + \ldots + \frac{n!}{(n-1)!} < 2n! + \frac{n!}{2} + \frac{n!}{2^2} + \frac{n!}{2^{n-2}} < 3n!$

    这说明 $backtrack$ 的调用次数是 $O(n!)$ 的。

    而对于 $backtrack$ 调用的每个叶结点（共 $n!$ 个），我们需要将当前答案使用 $O(n)$ 的时间复制到答案数组中，相乘得时间复杂度为 $O(n \times n!)$。

    因此时间复杂度为 $O(n \times n!)$。

* 空间复杂度： $O(n)$。除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 $O(n)$。
