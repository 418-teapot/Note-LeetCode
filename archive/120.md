# 三角形最小路径和

难度： 中等

关键词： 动态规划

## 题目描述

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

示例 1：

>**输入**： `triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]` <br>
**输出**： `11` <br>
**解释**： 如下面简图所示： <br>
```
   2
  3 4
 6 5 7
4 1 8 3
```
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

示例 2：

>**输入**： `triangle = [[-10]]` <br>
**输出**： `-10`

提示：

* `1 <= triangle.length <= 200` <br>
* `triangle[0].length == 1` <br>
* `triangle[i].length == triangle[i - 1].length + 1` <br>
* `-10^4 <= triangle[i][j] <= 10^4`

进阶：

* 你可以只使用 $O(n)$ 的额外空间（$n$ 为三角形的总行数）来解决这个问题吗？

## 题解

### 方法一：动态规划

#### 思路及算法

我们用 $f[i][j]$ 表示从三角形顶部走到位置 $(i, j)$ 的最小路径和。这里的位置 $(i, j)$ 指的是三角形中第 $i$ 行第 $j$ 列（均从 $0$ 开始编号）的位置。

由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 $(i, j)$，上一步就只能在位置 $(i - 1, j - 1)$ 或者位置 $(i - 1, j)$。我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：

$$
f[i][j] = \min(f[i-1][j-1], f[i-1][j]) + c[i][j]
$$

其中 $c[i][j]$ 表示位置 $(i, j)$ 对应的元素值。

注意第 $i$ 行有 $i+1$个元素，它们对应的 $j$ 的范围为 $[0, i]$。当 $j=0$ 或 $j=i$ 时，上述状态转移方程中有一些项是没有意义的。例如当 $j=0$ 时，$f[i−1][j−1]$ 没有意义，因此状态转移方程为：

$$
f[i][0] = f[i-1][0] + c[i][0]
$$

即当我们在第 $i$ 行的最左侧时，我们只能从第 $i−1$ 行的最左侧移动过来。当 $j=i$ 时，$f[i−1][j]$ 没有意义，因此状态转移方程为：

$$
f[i][i] = f[i-1][i-1] + c[i][i]
$$

即当我们在第 $i$ 行的最右侧时，我们只能从第 $i−1$ 行的最右侧移动过来。

最终的答案即为 $f[n−1][0]$ 到 $f[n−1][n−1]$ 中的最小值，其中 $n$ 是三角形的行数。

**细节**

状态转移方程的边界条件是什么？由于我们已经去除了所有「没有意义」的状态，因此边界条件可以定为：

$$
f[0][0] = c[0][0]
$$

即在三角形的顶部时，最小路径和就等于对应位置的元素值。这样一来，我们从 $1$ 开始递增地枚举 $i$，并在 $[0, i]$ 的范围内递增地枚举 $j$，就可以完成所有状态的计算。

#### 代码

```cpp
class Solution {
 public:
  int minimumTotal(vector<vector<int>>& triangle) {
    int n = triangle.size();
    vector<vector<int>> dp(n, vector<int>(n));
    dp[0][0] = triangle[0][0];
    for (int i = 1; i < n; ++i) {
      dp[i][0] = dp[i-1][0] + triangle[i][0];
      for (int j = 1; j < i; ++j) {
        dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j];
      }
      dp[i][i] = dp[i-1][i-1] + triangle[i][i];
    }
    return *min_element(dp[n-1].begin(), dp[n-1].end());
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(n^2)$，其中 $n$ 是三角形的行数。
* 空间复杂度： $O(n^2)$。我们需要一个 $n∗n$ 的二维数组存放所有的状态。

### 方法二：动态规划 + 空间优化

#### 思路及算法

在题目描述中的「进阶」部分，提到了可以将空间复杂度优化至 $O(n)$。

我们回顾方法一中的状态转移方程：

$$
\begin{aligned}
f[i][j] = \begin{cases}
  f[i-1][0] + c[i][0], & j=0 \\
  f[i-1][i-1] + c[i][i], & j=i \\
  \min(f[i-1][j-1], f[i-1][j]) + c[i][j], & \text{otherwise}
\end{cases}
\end{aligned}
$$

可以发现，$f[i][j]$ 只与 $f[i-1][..]$ 有关，而与 $f[i-2][..]$ 及之前的状态无关，因此我们不必存储这些无关的状态。具体地，我们使用两个长度为 $n$ 的一维数组进行转移，将 $i$ 根据奇偶性映射到其中一个一维数组，那么 $i−1$ 就映射到了另一个一维数组。这样我们使用这两个一维数组，交替地进行状态转移。

上述方法的空间复杂度为 $O(n)$，使用了 $2n$ 的空间存储状态。我们还可以继续进行优化吗？

答案是可以的。我们从 $i$ 到 $0$ 递减地枚举 $j$，这样我们只需要一个长度为 $n$ 的一维数组 $f$，就可以完成状态转移。

为什么只有在递减地枚举 $j$ 时，才能省去一个一维数组？当我们在计算位置 $(i, j)$ 时，$f[j+1]$ 到 $f[i]$ 已经是第 $i$ 行的值，而 $f[0]$ 到 $f[j]$ 仍然是第 $i−1$ 行的值。此时我们直接通过

$$
f[j] = \min(f[j-1], f[j]) + c[i][j]
$$

进行转移，恰好就是在 $(i-1, j-1)$ 和 $(i-1, j)$ 中进行选择。但如果我们递增地枚举 $j$，那么在计算位置 $(i, j)$ 时，$f[0]$ 到 $f[j−1]$ 已经是第 $i$ 行的值。如果我们仍然使用上述状态转移方程，那么是在 $(i, j-1)$ 和 $(i-1, j)$ 中进行选择，就产生了错误。

这样虽然空间复杂度仍然为 $O(n)$，但我们只使用了 $n$ 的空间存储状态，减少了一半的空间消耗。

#### 代码

```cpp
class Solution {
 public:
  int minimumTotal(vector<vector<int>>& triangle) {
    int n = triangle.size();
    vector<int> dp(n);
    dp[0] = triangle[0][0];
    for (int i = 1; i < n; ++i) {
      dp[i] = dp[i-1] + triangle[i][i];
      for (int j = i - 1; j > 0; --j) {
        dp[j] = min(dp[j - 1], dp[j]) + triangle[i][j];
      }
      dp[0] += triangle[i][0];
    }
    return *min_element(dp.begin(), dp.end());
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(n^2)$，其中 $n$ 是三角形的行数。
* 空间复杂度： $O(n)$。