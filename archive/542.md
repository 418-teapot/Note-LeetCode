# 01 矩阵

难度： 中等

关键词： 矩阵、广度优先搜索、动态规划

## 题目描述

给定一个由 `0` 和 `1` 组成的矩阵 `mat`，请输出一个大小相同的矩阵，其中每一个格子是 `mat` 中对应位置元素到最近的 `0` 的距离。

两个相邻元素间的距离为 `1`。

示例 1：

![](https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png)

>**输入**： `mat = [[0,0,0],[0,1,0],[0,0,0]]` <br>
**输出**： `[[0,0,0],[0,1,0],[0,0,0]]`

示例 2：

![](https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png)

>**输入**： `mat = [[0,0,0],[0,1,0],[1,1,1]]` <br>
**输出**： `[[0,0,0],[0,1,0],[1,2,1]]`

提示：

* `m == mat.length`
* `n == mat[i].length`
* `1 <= m, n <= 10^4`
* `1 <= m * n <= 10^4`
* `mat[i][j]` is either `0` or `1`
* `mat` 中至少有一个 `0`

## 题解

### 方法一：广度优先搜索

#### 思路及算法

多源BFS问题。

该题为矩阵问题，但比较适用于图论解决。

相邻结点的边权相同，求每个合法结点到目标结点的最短距离的最小值。

暴力的做法是枚举每个合法结点，从每个合法结点到目标结点做 BFS，再在结果集中取一个最小值。

优化的BFS做法，即设置一个超级源点，超级源点向每个合法结点连一条边，从超级源点到目标结点做 BFS，求出的距离即为从每个合法结点到目标结点的最短距离的最小值 + 1。实际上并不需要真的创建一个超级源点并向每个合法结点连一条边，由于超级源点入队出队后，会将其可达结点加入队列，即一开始将所有合法结点加入队列且将它们到目标结点的距离设成 0（有超级源点时为 1 ）即可。

#### 代码

C++:
```cpp
class Solution {
 public:
  const int dx[4] = {0, 0, -1, 1};
  const int dy[4] = {-1, 1, 0, 0};
  vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
    int m = mat.size(), n = mat[0].size();
    vector<vector<int>> res(m, vector<int>(n));
    vector<vector<int>> visited(m, vector<int>(n));
    queue<pair<int, int>> q;
    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (mat[i][j] == 0) {
          q.emplace(i, j);
          visited[i][j] = 1;
        }
      }
    }

    while (!q.empty()) {
      auto [i, j] = q.front();
      q.pop();
      for (int k = 0; k < 4; ++k) {
        int mi = i + dx[k];
        int mj = j + dy[k];
        if (mi >= 0 && mi < m && mj >= 0 && mj < n && !visited[mi][mj]) {
          res[mi][mj] = res[i][j] + 1;
          q.emplace(mi, mj);
          visited[mi][mj] = 1;
        }
      }
    }

    return res;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(mn)$，其中 $m$ 为矩阵行数， $n$ 为矩阵列数，即矩阵元素个数。广度优先搜索中每个位置最多只会被加入队列一次，因此只需要 $O(mn)$ 的时间复杂度。
* 空间复杂度： $O(mn)$。除答案数组外，最坏情况下矩阵里所有元素都为 $0$，全部被加入队列中，此时需要 $O(mn)$ 的空间复杂度。

### 方法二：动态规划

#### 思路及算法

如果 $0$ 在矩阵中的位置是 $(i_0, j_0)$， $1$ 在矩阵中的位置是 $(i_1, j_1)$，那么我们可以直接算出 $0$ 和 $1$ 之间的距离。因为我们从 $1$ 到 $0$ 需要在水平方向走 $|i_0 - i_1|$ 步，竖直方向走 $|j_0 - j_1|$ 步，那么它们之间的距离就为 $|i_0 - i_1| + |j_0 - j_1|$。

对于矩阵中的任意一个 $1$ 以及一个 $0$，我们如何从这个 $1$ 到达 $0$ 并且距离最短呢？根据上面的做法，我们可以从 $1$ 开始，先在水平方向移动，直到与 $0$ 在同一列，随后再在竖直方向上移动，直到到达 $0$ 的位置。这样一来，从一个固定的 $1$ 走到任意一个 $0$，在距离最短的前提下可能有四种方法：

* 只有 **水平向左移动** 和 **竖直向上移动**；
* 只有 **水平向左移动** 和 **竖直向下移动**；
* 只有 **水平向右移动** 和 **竖直向上移动**；
* 只有 **水平向右移动** 和 **竖直向下移动**。

这样以来，我们就可以使用动态规划解决这个问题了。我们用 $f(i, j)$ 表示位置 $(i, j)$ 到最近的 $0$ 的距离。如果我们只能「水平向左移动」和「竖直向上移动」，那么我们可以向上移动一步，再移动 $f(i - 1, j)$ 步到达某一个 $0$，也可以向左移动一步，再移动 $f(i, j - 1)$ 步到达某一个 $0$。因此我们可以写出如下的状态转移方程：

$$
f(i, j) = \begin{cases}
1 + \min\big(f(i - 1, j), f(i, j - 1)\big) & \text{位置 } (i, j) \text{ 的元素为 } 1 \\
0 & \text{位置 } (i, j) \text{ 的元素为 } 0
\end{cases}​
$$

对于另外三种移动方法，我们也可以写出类似的状态转移方程，得到四个 $f(i, j)$ 的值，那么其中最小的值就表示位置 $(i, j)$ 到最近的 $0$ 的距离。

#### 代码

C++:
```cpp
class Solution {
 public:
  vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
    int m = mat.size(), n = mat[0].size();
    vector<vector<int>> dp(m, vector<int>(n, INT_MAX/2));
    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (mat[i][j] == 0) dp[i][j] = 0;
      }
    }
    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        if (i - 1 >= 0) dp[i][j] = min(dp[i][j], dp[i-1][j] + 1);
        if (j - 1 >= 0) dp[i][j] = min(dp[i][j], dp[i][j-1] + 1);
      }
    }
    for (int i = 0; i < m; ++i) {
      for (int j = n - 1; j >= 0; --j) {
        if (i - 1 >= 0) dp[i][j] = min(dp[i][j], dp[i-1][j] + 1);
        if (j + 1 < n)  dp[i][j] = min(dp[i][j], dp[i][j+1] + 1);
      }
    }
    for (int i = m - 1; i >= 0; --i) {
      for (int j = 0; j < n; ++j) {
        if (i + 1 < m)  dp[i][j] = min(dp[i][j], dp[i+1][j] + 1);
        if (j - 1 >= 0) dp[i][j] = min(dp[i][j], dp[i][j-1] + 1);
      }
    }
    for (int i = m - 1; i >= 0; --i) {
      for (int j = n - 1; j >= 0; --j) {
        if (i + 1 < m)  dp[i][j] = min(dp[i][j], dp[i+1][j] + 1);
        if (j + 1 < n)  dp[i][j] = min(dp[i][j], dp[i][j+1] + 1);
      }
    }
    return dp;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(mn)$，其中 $m$ 为矩阵行数， $n$ 为矩阵列数。计算 $dp$ 数组的过程中我们需要遍历四次矩阵，因此时间复杂度为 $O(4mn)=O(mn)$。
* 空间复杂度： $O(1)$，这里我们只计算额外的空间复杂度。除了答案数组以外，我们只需要常数空间存放若干变量。

#### 改进

其实有一些重复计算的地方。实际上，我们只需要保留

* 只有 **水平向左移动** 和 **竖直向上移动**；
* 只有 **水平向右移动** 和 **竖直向下移动**。

这两者即可。

首先证明右上，给出性质：假如距离 $(i,j)$ 最近的点在 $(i-a,j+b)$ 其中 $a>0,b>0$，则距离 $(i,j+b)$ 最近的点在 $(i-a,j+b)$。 用反证法证明：如果距离 $(i,j+b)$ 最近的点 $(x,y)$ 不在 $(i-a,j+b)$，则 $(i,j+b)$ 和 $(x,y)$ 距离 $d<a$，这时点 $(i,j)$ 和 $(x,y)$ 的距离 $d'<=b+d<a+b$，与假设矛盾。

利用这个性质，如果距离 $(i,j)$ 最近的点在 $(i-a,j+b)$ 其中 $a>0,b>0$，在第一次 dp 时 $(i,j)$ 没有取得最优值，但在第二次 dp 时由于 $(i,j+b)$ 的最优值已经取得(因为这个最优值在他正上方)，所以 $(i,j)$ 也能取得最优值。

左下同理。