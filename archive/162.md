# 寻找峰值

难度： 中等

关键词： 贪心、二分查找

## 题目描述

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞`。

你必须实现时间复杂度为 $O(\log n)$ 的算法来解决此问题。

示例 1：

>**输入**： `nums = [1,2,3,1]` <br>
**输出**： `2` <br>
**解释**： `3` 是峰值元素，你的函数应该返回其索引 `2`。

示例 2：

>**输入**： `nums = [1,2,1,3,5,6,4]` <br>
**输出**： `1` 或 `5` <br> 
**解释**： 你的函数可以返回索引 `1`，其峰值元素为 `2`；或者返回索引 `5`， 其峰值元素为 `6`。

提示：

* `1 <= nums.length <= 1000`
* `-2^31 <= nums[i] <= 2^31 - 1`
* 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

## 题解

### 贪心二分

#### 算法及思路

在题目描述中出现了 `nums[-1] = nums[n] = -∞` 和 `nums[i] != nums[i + 1]`，这就代表着对于任意数组而言，一定存在峰值。

不难证明，如果当前位置大于其左边界或者右边界，那么在当前位置的右边或左边必然存在峰值。

换句话说，对于一个满足 $nums[x] > nums[x−1]$ 的位置， $x$ 的右边一定存在峰值；或对于一个满足 $nums[x] > nums[x+1]$ 的位置， $x$ 的左边一定存在峰值。

因此这里的「二段性」其实是指：在以 $mid$ 为分割点的数组上，根据 $nums[mid]$ 与 $nums[mid \pm 1]$ 的大小关系，可以确定其中一段满足「必然有解」，另外一段不满足「必然有解」（可能有解，可能无解）。

至此，我们证明了始终选择大于边界一端进行二分，可以确保选择的区间一定存在峰值，并随着二分过程不断逼近峰值位置。

#### 代码

C++:
```cpp
class Solution {
 public:
  int findPeakElement(vector<int>& nums) {
    int len = nums.size();
    int left = 0, right = len - 1;
    while (left < right) {
      int mid = left + ((right - left) >> 1);
      if (nums[mid] < nums[mid+1]) {
        left = mid + 1;
      } else {
        right = mid;
      }
    }
    return left;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(\log{n})$
* 空间复杂度： $O(1)$