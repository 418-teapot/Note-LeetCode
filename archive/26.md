# 删除有序数组中的重复项

难度： 简单

关键词： 双指针、快慢指针

## 题目描述

给你一个 **升序排列** 的数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **只出现一次**，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致**。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组 `nums` 的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k`。

不要使用额外的空间，你必须在 **原地修改输入数组** 并在使用 $O(1)$ 额外空间的条件下完成。

示例 1：

>**输入**： `nums = [1,1,2]` <br>
**输出**： `2, nums = [1,2,_]` <br>
**解释**： 函数应该返回新的长度 `2` ，并且原数组 `nums` 的前两个元素被修改为 `1, 2`。不需要考虑数组中超出新长度后面的元素。

示例 2：

>**输入**： `nums = [0,0,1,1,1,2,2,3,3,4]` <br>
**输出**： `5, nums = [0,1,2,3,4]` <br>
**解释**： 函数应该返回新的长度 `5`， 并且原数组 `nums` 的前五个元素被修改为 `0, 1, 2, 3, 4`。不需要考虑数组中超出新长度后面的元素。

提示：

* `0 <= nums.length <= 3 * 104`
* `-104 <= nums[i] <= 104`
* `nums` 已按 **升序** 排列

## 题解

### 双指针

#### 思路及算法

由于给定的数组 $nums$ 是有序的，因此对于任意 $i < j$，如果 $nums[i] == nums[j]$，则对任意 $i \le k \le j$，必有 $nums[i] == nums[k] == nums[j]$，即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。

定义两个指针 $fast$ 和 $slow$ 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示处理好的数组的最后一个位置。只有当 $fast$ 和 $slow$ 所指向的值不一致时，才将 $fast$ 的值添加到 $slow$ 的下一个位置。

#### 代码

C++:
```cpp
class Solution {
 public:
  int removeDuplicates(vector<int>& nums) {
    int len = nums.size();
    if (len == 0) return 0;
    int slow = 0;
    for (int fast = 0; fast < len; ++fast) {
      if (nums[fast] != nums[slow]) {
        nums[++slow] = nums[fast];
      }
    }
    return slow + 1;
  }
};
```

#### 复杂度分析

* 时间复杂度： $O(n)$，其中 $n$ 是数组的长度。快指针和慢指针最多各移动 $n$ 次。
* 空间复杂度： $O(1)$。只需要使用常数的额外空间。